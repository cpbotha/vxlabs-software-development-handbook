#+TITLE: vxlabs software development handbook
#+DATE: 2021-02-03
#+AUTHOR_not: Dr Charl P. Botha <cpbotha@vxlabs.com>
#+AUTHOR:

#+HUGO_BASE_DIR: ../../../../web/vxlabs.com/
#+HUGO_SECTION: post/2021

#+EXPORT_FILE_NAME: index.md
#+HUGO_BUNDLE: vxlabs-software-development-handbook
#+HUGO_URL: /software-development-handbook/

#+HUGO_CATEGORIES: handbook
#+HUGO_TAGS: "best practices" "code style" "coding conventions" "programming style" "software development"

# when exporting to hugo, need author here. for other exports, re-enable AUTHOR above
# the problem is that ox-hugo usually exports author array: https://ox-hugo.scripter.co/doc/author/
#+HUGO_CUSTOM_FRONT_MATTER: :author "Dr Charl P. Botha" :org true
#+HUGO_AUTO_SET_LASTMOD: t

#+HUGO_DRAFT: true

* Introduction

This is the *heavily in-progress* open source vxlabs software development
handbook.

It contains a number of best practices for building software, generally
web-based, using Python on the backend and TypeScript for the
frontend. However, most of the guidelines should be more broadly applicable.

I am making this available under the BSD 3-clause open source license in case
you find any part of this useful. Feel free to pick what works for you, and
ignore the rest.

- Status: *This handbook is about 40% complete on 2021-02-03*. The plan is to
  get a complete v1 posted in Q1 of 2021.
- Canonical URL: https://vxlabs.com/software-development-handbook/
- Github: https://github.com/cpbotha/vxlabs-software-development-handbook

* General

** Apply The Joel Test: 12 Steps to Better Code

Joel Spolsky, co-founder of the StackOverflow empire, amongst other great
things, [[https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/][published the following 12-point checklist]] that you can use to evaluate
your process and your team:

#+begin_quote
1. Do you use source control?
2. Can you make a build in one step?
3. Do you make daily builds?
4. Do you have a bug database?
5. Do you fix bugs before writing new code?
6. Do you have an up-to-date schedule?
7. Do you have a spec?
8. Do programmers have quiet working conditions?
9. Do you use the best tools money can buy?
10. Do you have testers?
11. Do new candidates write code during their interview?
12. Do you do hallway usability testing?

A score of 12 is perfect, 11 is tolerable, but 10 or lower and you've got
serious problems. The truth is that most software organizations are running
with a score of 2 or 3, and they need serious help, because companies like
Microsoft run at 12 full-time.
#+end_quote

These are some of /the/ core characteristics of a great software process.

If you're able to increase your score by any number, you're doing good work.


** Comment your code
:PROPERTIES:
:CUSTOM_ID: comment-your-code
:END:

The most obvious mark of good programmers is that they write good code.

What sets /great programmers/ apart from good programmers, is that, in addition
to building beautiful systems, they have a continuous and long-lasting positive
effect on the capabilities of those around them.

In other words, a great programmer /helps team-mates to level-up/.

In this way, great programmers continuously amplify the quality and output of
their whole team. In these cases, "10x" is perhaps not even that much of an
exaggeration.

One of the best ways that /you/ can help your team-mates, current and future,
to be better at their work, is to comment your code.

Put yourself in the shoes of a future team-mate who is most probably going to
have to understand your code to add a new feature to the system, or to fix a
bug.

The less time they spend understanding your code, the more time they'll have to
do their work well.

Give them as much high-quality context as you can in the comments.

Try to answer questions like:

- Where and how does this module fit into the whole product?
- Why exactly is this implemented in a surprising way?
- How does this non-trivial algorithm work?

Bonus points if you can add an example of usage to the comments!

This is really not about you believing that your code speaks for itself.

Instead think about your future team-mates who will either be really happy with
the guidance you give them, or perhaps a great deal less happy with the extra
hours they were forced to spend in order to divine your willfully undocumented
intentions.

Be kind. Comment your code.

** Use automated testing

** Use automated linting

From [[https://en.wikipedia.org/wiki/Lint_(software)][the Wikipedia page on the topic]]:

#+begin_quote
lint, or a linter, is a static code analysis tool used to flag programming
errors, bugs, stylistic errors, and suspicious constructs. The term originates
from a Unix utility that examined C language source code.
#+end_quote

Many modern languages have great linters available.

Ensure that you have these configured and active for your whole team, ideally
directly in the IDE so that programmers get continuous and real-time feedback
on the quality of the code that they are writing so that that they can further
improve their work.

See [[#flake8][flake8 for Python]] and [[#eslint][eslint for TypeScript]] below for specific examples.

** Use automated formatting

** Ensure your top-level README can ramp-up new devs

** Prefer TypeScript over JavaScript
:PROPERTIES:
:CUSTOM_ID: typescript-over-javascript
:END:

This is what it states [[https://www.typescriptlang.org/][on the tin]]:

#+begin_quote
TypeScript extends JavaScript by adding types.

By understanding JavaScript, TypeScript saves you time catching errors and
providing fixes before you run code.
#+end_quote

From my practical experience, after years of as-modern-as-possible JavaScript
and initially /resisting/ the perceived extra burden of using TypeScript,
TypeScript improves the quality of our products by:

1. Augmenting our code documentation with rich and structured information about
   the exact nature of data going in and out of functions.
2. Enabling IDE tooling to give much better interactive assistance as we
   work. In other words, the IDE is able to surface and /apply/ the
   typing-information that has been specified previously.
3. Enabling tooling, both IDE and off-line checks, to catch typing and other
   errors in their tracks.

The general arguments for [[#comment-your-code][commenting your code]] up above also hold for using
TypeScript instead of JavaScript. By doing this, you can help your team-mates,
current and future, to be better. (You'll probably also be helping future you
at some point.)

As if that's not enough, here's some social proof:

In the 2020 Stack Overflow developer survey, [[https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved][TypeScript had moved all the way
up to the second position, right below Rust, on the list of /most loved/
languages]].

* Version control (with git)

** Follow the 7 rules of writing good commit messages
:PROPERTIES:
:CUSTOM_ID: good-commit-messages
:END:


See [[https://chris.beams.io/posts/git-commit/][this blog post by Chris Beams]] with the motivation and background of these
rules.

I repeat the rules below for your convenience:

1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Wrap the body at 72 characters
7. Use the body to explain what and why vs.Â how

The post by Beams contains a great example of a rather extensive git
commit message that I reproduce below, also for your convenience.

Commit messages generally stop at the first line, but that means many
people somehow manage to break the first five of the seven rules, so at
least pay careful attention to the example's first line.

#+begin_example
  Summarize changes in around 50 characters or less

  More detailed explanatory text, if necessary. Wrap it to about 72
  characters or so. In some contexts, the first line is treated as the
  subject of the commit and the rest of the text as the body. The
  blank line separating the summary from the body is critical (unless
  you omit the body entirely); various tools like `log`, `shortlog`
  and `rebase` can get confused if you run the two together.

  Explain the problem that this commit is solving. Focus on why you
  are making this change as opposed to how (the code explains that).
  Are there side effects or other unintuitive consequences of this
  change? Here's the place to explain them.

  Further paragraphs come after blank lines.

   - Bullet points are okay, too

   - Typically a hyphen or asterisk is used for the bullet, preceded
     by a single space, with blank lines in between, but conventions
     vary here

  If you use an issue tracker, put references to them at the bottom,
  like this:

  Resolves: #123
  See also: #456, #789
#+end_example

** Rebase feature branches before review and before merging
:PROPERTIES:
:CUSTOM_ID: rebase-before-merging
:END:

Rebasing before review and again before merging, with a merge commit, results
in a more linear git history where each feature branch is clearly separated
from the feature branchs before and after it.

When this rebasing approach is combined with [[#good-commit-messages][writing good commit messages]], your
git history becomes a usable and, importantly, linear hierarchical record of
which changes happened when, both at the commit level, and at the feature
level.

Below an example is shown from a real project employing [[#gitflow][gitflow]] and the
rebase-before-merge guideline.

Note that each discrete feature occupies its own horizontal duration with no
overlaps. Furthermore, each feature branch is ended by a merge commit which
contains more information about that feature.

#+CAPTION: Linear hierarchical history thanks to rebasing before merging.
#+CAPTION: Merge commits in each case contain more information about the feature and metadata like the PR reviewers.
[[file:magit-rebase-good-history.png][file:magit-rebase-good-history.png]]

In exceptional cases, it /can/ happen (but it shouldn't) that a feature branch
has grown so complex to make a rebase prohibitively difficult. In these cases,
after this has been discussed with the team lead, one could consider merging
=develop= into the feature branch instead of rebasing. However, this should be
considered a last exit.

** Use gitflow for versioned software releases
:PROPERTIES:
:CUSTOM_ID: gitflow
:END:

The [[https://nvie.com/posts/a-successful-git-branching-model/][original gitflow branching model was published by Vincent Driessen on his
blog]].

Please go read the whole post as soon as you can make some time.

Until then, refer to one of Driessen's great diagrams below, and follow these
updated and highly paraphrased instructions:

- Your git repo has at least two major branches: =develop= and =main=.
- Every new feature, bug fix or task is developed in a feature branch, branched
  from =develop=.
- (After the pull request and review process,) that feature branch will be merged
  back into develop.
  - We add here the extra requirement that the feature branch is rebased from
    master before review, and again before merging, see [[#rebase-before-merging][rebase-before-merging]]
    above.
- When you are preparing for a release, create a new branch of =develop= and
  work on that until ready for release.
  - Tag the specific commit that makes it into release.
- After release, and hopefully fame and fortune, merge the =release-= branch in
  question back into =develop=, and also, quite importantly into =main=.
  - In other words, =main= is always production-ready code.
- If you ever need to make an urgent hotfix to a production release, branch
  from production-ready =main= and prepare hotfix release.
  - Once the hotfix release is done, merge back into =main= and into =develop=.
  
#+CAPTION: The gitflow model, including develop, master (now main), release branches and hotfixes.
#+ATTR_HTML: :width 320
[[file:gitflow_hotfixbranch_nvie.com.png][file:gitflow_hotfixbranch_nvie.com.png]]

Please do take note of Driessen's update of March 5, 2020, where he recommends
that gitflow should not be treated as dogma.

It's a guideline that is to be adapted for your situation.

** Use GitHub flow for continuous delivery

If your team does continuous delivery, i.e. not fully versioned software
releases, consider a simpler model than gitflow, for example [[https://guides.github.com/introduction/flow/][GitHub flow]].

My experience is mostly with versioned software releases and gitflow, so I'm
keeping this section short.

** Before merging, apply the merge request checklist

From the following Tweet by [[https://twitter.com/pablosaraiva][pablosaraiva]]:

#+begin_export html
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">- Changes a single
thing;<br>- Has a good tittle;<br>- Has a link to the ticket;<br>- Was pair
reviewed;<br>- Build and tests pass;<br>- Static code analysis pass
(sonarqube);<br>- Code changes are simple to understand;<br>- Things that need
documentation are documented;<br>- Code has test coverage.</p>&mdash;
pablosaraiva (@pablosaraiva) <a
href="https://twitter.com/pablosaraiva/status/1350386465138728961?ref_src=twsrc%5Etfw">January
16, 2021</a></blockquote> <script async
src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
#+end_export

Following is a fixed and grouped version of the checklist.

Before a merge request can be merged, the following has to be checked:

The request:

1. Changes a single thing;
2. Has a good title;
3. Has a link to the ticket;
4. Was peer reviewed;

In addition:

5. Build and tests pass;
6. Static code analysis pass;
7. Code changes are simple to understand;
8. Things that need documentation are documented;
9. Code has test coverage.

* Usability

** Read and absorb Steve Krug's "Don't make me think"

This book is a great introduction to website (and to a large extent general UI)
usability that gives insight into the mind of that very mysterious being,
namely "the user".

If you don't have time at this moment to read this compact book, you could read
my book notes in the meantime. (to be published)

- [ ] mention usability testing

** Pick and use a design system and accompanying toolkit

- [ ] state problem: we are almost all engineering
- [ ] motivate design system + toolkit as engineer-friendly solution for
  practical usability

We use [[https://material.io/design][Material Design]] along with [[https://material-ui.com/][material-ui]] for our React frontends.

* Python
  
** Type annotate all the things

The same three arguments as for [[#typescript-over-javascript][Prefer TypeScript]] up above hold for Python type
annotation.

In short, type annotation in Python is structured, human- and
machine-understandable type information that enriches your documentation, can
be used by IDEs to assist you and your team-mates in writing code, and can be
used by IDEs and offline tools such as mypy to help catch bugs before they
happen.

During the Python Language Summit 2020, [[https://pyfound.blogspot.com/2020/04/the-path-forward-for-typing-python.html][Guido van Rossum remarked that since
2014, when Python type annotations were introduced, ten type-checking PEPs have
been approved]].

As an additional example, the Apache Beam project is quite assertive in its
post introducing improved annotation for their Python SDK (emphasis mine):

#+begin_quote
The *importance of static type checking in a dynamically typed language like
Python is not up for debate*. Type hints allow developers to leverage a strong
typing system to:

- write better code,
- self-document ambiguous programming logic, and
- inform intelligent code completion in IDEs like PyCharm.
#+end_quote

** Use poetry for package and dependency management

** Use the black formatter with defaults

The [[https://black.readthedocs.io/en/stable/the_black_code_style.html#line-length][black formatter documentation makes good arguments for line length 88]],
including that it's more than 80 (can't argue with that), but perhaps most
importantly that longer line lengths could be problematic for folks with sight
difficulties.

Furthermore, sticking to the formatter default means one fewer setting
that has to be modified.

** Use flake8 to check your Python as you work
:PROPERTIES:
:CUSTOM_ID: flake8
:END:

Configure your IDE to apply flake8 checks continuously as you work.

We prefer the google import style (grouped from built-in to third-party,
sorted within groups), and numpy docstrings.

The following =.flake8=, to be installed in the root directory of your
project, takes care of what's mentioned here.

#+begin_example
  [flake8]
  max-line-length = 88
  import-order-style = google
  docstring-convention = numpy
  # https://black.readthedocs.io/en/stable/the_black_code_style.html#slices
  ignore = E203
#+end_example

** Use cell-based debug scripts

Follow the convention that all tests (we use pytest) are in files named
=test_*.py=, and debug and test scripts are named =debug_*.py=.

** Prefer Django

Django is the highest quality Python web-framework.

It comes with almost all batteries included, it is exhaustively tested
and it is well-documented.

Importantly, it is quite opinionated, meaning that you don't have to
waste time deciding on alternative solutions for aspects of your
back-end. The solutions are already all there, and they've been
battle-tested. However, many of these components can be swapped out if
you really want to.

The Django ORM by itself is worth the price of admission.

In addition to all of that, the large and active community means that:

1. The strange behaviour you're seeing in your app has already been
   explored, documented and fixed by someone else. Just search.
2. There are multiple libraries and configurations for any possible
   requirement you might have.

Sometimes people operate on the assumption that Django is somehow too
large for a small service, and then choose some other smaller-appearing
framework.

Why would you do this?

If you use a subset of Django's functionality, it becomes a smaller
framework in memory and in complexity.

However, in future you have the option of switching on any of the
built-in functionality when the project requirements change.

To summarize: Choose Django, unless you have really good and really
specific reasons not to do so.

*** What about FastAPI?
    :PROPERTIES:
    :CUSTOM_ID: what-about-fastapi
    :END:
We have used [[https://fastapi.tiangolo.com/][FastAPI]] in the past for
a machine learning project that required asynchronous operation (for
pushing results via websockets to the interactive web frontend) but did
not require a database component or any user authentication.

Although our experience with this impressive piece of software was
great, our Django products have seen many more users and many more years
of stable operation.

Furthermore, since then
[[https://docs.djangoproject.com/en/3.1/topics/async/][Django 3.1 has
gained many more async capabilities]]. Faced with the same requirements
today, we might choose differently.

Again, choose Django, unless you have really good and really specific
reasons not to do so.

* TypeScript

** Use eslint and configure your IDE to apply it continuously
:PROPERTIES:
:CUSTOM_ID: eslint
:END:

This is following 

** Group your imports

** Use the prettier formatter

Using an opinionated and automatic code formatter like
[[https://prettier.io/][prettier]] saves you time, because you don't
have to think about formatting anymore, and perhaps more importantly,
you don't have to debate about it with anyone.

[[https://prettier.io/docs/en/options.html#print-width][prettier
recommends against any other =printWidth= than 80]], because their
algorithm does not treat it as a maximum length, but rather as a desired
length.

Due to this limitation, and because TypeScript is different from Python,
here we recommend going with prettier's defaults.

Configure your IDE or editor to run prettier automatically on save:

*** Visual Studio Code

Install the [[https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode]["Prettier - Code formatter" extension (extension id:
=esbenp.prettier-vscode=)]].

Activate =editor.formatOnSave=.

* React

